<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>midgard.parsers - Midgard</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">Midgard</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">How-to <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../howto/testing/">Testing</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">API <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../midgard/">midgard</a>
</li>
                                    
<li >
    <a href="../midgard-collections/">midgard.collections</a>
</li>
                                    
<li >
    <a href="../midgard-config/">midgard.config</a>
</li>
                                    
<li >
    <a href="../midgard-coords/">midgard.coords</a>
</li>
                                    
<li >
    <a href="../midgard-dev/">midgard.dev</a>
</li>
                                    
<li >
    <a href="../midgard-files/">midgard.files</a>
</li>
                                    
<li >
    <a href="../midgard-ionosphere/">midgard.ionosphere</a>
</li>
                                    
<li >
    <a href="../midgard-math/">midgard.math</a>
</li>
                                    
<li class="active">
    <a href="./">midgard.parsers</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../midgard-math/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="disabled">
                                <a rel="prev" >
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#midgardparsers">midgard.parsers</a></li>
            <li><a href="#names">names()</a></li>
            <li><a href="#parse_file">parse_file()</a></li>
        <li class="main "><a href="#midgardparsers_parser">midgard.parsers._parser</a></li>
            <li><a href="#parser">Parser</a></li>
        <li class="main "><a href="#midgardparsers_parser_chain">midgard.parsers._parser_chain</a></li>
            <li><a href="#chainparser">ChainParser</a></li>
            <li><a href="#parserdef">ParserDef</a></li>
        <li class="main "><a href="#midgardparsers_parser_line">midgard.parsers._parser_line</a></li>
            <li><a href="#lineparser">LineParser</a></li>
        <li class="main "><a href="#midgardparsers_parser_rinex">midgard.parsers._parser_rinex</a></li>
            <li><a href="#rinexheader">RinexHeader</a></li>
            <li><a href="#rinexparser">RinexParser</a></li>
            <li><a href="#parser_cache">parser_cache()</a></li>
        <li class="main "><a href="#midgardparsers_parser_sinex">midgard.parsers._parser_sinex</a></li>
            <li><a href="#sinexblock">SinexBlock</a></li>
            <li><a href="#sinexfield">SinexField</a></li>
            <li><a href="#sinexparser">SinexParser</a></li>
            <li><a href="#parsing_factory">parsing_factory()</a></li>
            <li><a href="#parsing_matrix_factory">parsing_matrix_factory()</a></li>
        <li class="main "><a href="#midgardparsersgalileo_constellation_html">midgard.parsers.galileo_constellation_html</a></li>
            <li><a href="#galileoconstellationhtmlparser">GalileoConstellationHTMLParser</a></li>
        <li class="main "><a href="#midgardparsersgnss_antex">midgard.parsers.gnss_antex</a></li>
            <li><a href="#antexparser">AntexParser</a></li>
        <li class="main "><a href="#midgardparsersrinex3_header">midgard.parsers.rinex3_header</a></li>
            <li><a href="#rinex3headermixin">Rinex3HeaderMixin</a></li>
            <li><a href="#rinex3headerparser">Rinex3HeaderParser</a></li>
        <li class="main "><a href="#midgardparsersrinex_obs">midgard.parsers.rinex_obs</a></li>
            <li><a href="#rinexobsparser">RinexObsParser</a></li>
        <li class="main "><a href="#midgardparsersvlbi_source_names">midgard.parsers.vlbi_source_names</a></li>
            <li><a href="#vlbisourcenamesparser">VlbiSourceNamesParser</a></li>
        <li class="main "><a href="#midgardparserswip_rinex2_obs">midgard.parsers.wip_rinex2_obs</a></li>
            <li><a href="#rinex2obsparser">Rinex2ObsParser</a></li>
        <li class="main "><a href="#midgardparserswip_rinex3_obs">midgard.parsers.wip_rinex3_obs</a></li>
            <li><a href="#rinex3obsparser">Rinex3ObsParser</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="midgardparsers">midgard.parsers</h1>
<p>Framework for parsers</p>
<p><strong>Description:</strong></p>
<p>To add a new parser, simply create a new .py-file which defines a class
inheriting from parsers.Parser. The class needs to be decorated with the
<code>midgard.dev.plugins.register</code> decorator as follows:</p>
<pre><code>from midgard.parsers import parser
from midgard.lib import plugins

@plugins.register
class MyNewParser(parser.Parser):
    ...
</code></pre>
<p>To use a parser, you will typically use the <code>parse_file</code>-function defined below</p>
<pre><code>from midgard import parsers
my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...)
my_data = my_new_parser.as_dict()
</code></pre>
<p>The name used in <code>parse_file</code> to call the parser is the name of the module
(file) containing the parser.</p>
<h2 id="names"><strong>names</strong>()</h2>
<p>Full name: <code>midgard.parsers.names</code></p>
<p>Signature: <code>() -&gt; List[str]</code></p>
<p>List the names of the available parsers</p>
<p><strong>Returns:</strong></p>
<p>Names of the available parsers</p>
<h2 id="parse_file"><strong>parse_file</strong>()</h2>
<p>Full name: <code>midgard.parsers.parse_file</code></p>
<p>Signature: <code>(parser_name:str, file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, parser_logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;, timer_logger:Union[Callable[[str], NoneType], NoneType]=None, use_cache:bool=False, **parser_args:Any) -&gt; midgard.parsers._parser.Parser</code></p>
<p>Use the given parser on a file and return parsed data</p>
<p>Specify <code>parser_name</code> and <code>file_path</code> to the file that should be parsed. The following parsers are available:</p>
<p>{doc_parser_names}</p>
<p>Data can be retrieved either as Dictionaries, Pandas DataFrames or Midgard Datasets by using one of the methods
<code>as_dict</code>, <code>as_dataframe</code> or <code>as_dataset</code>.</p>
<p>Example:</p>
<pre><code>&gt;&gt;&gt; df = parse_file('rinex2_obs', 'ande3160.16o').as_dataframe()  # doctest: +SKIP
</code></pre>
<p><strong>Args:</strong></p>
<ul>
<li><code>parser_name</code>:    Name of parser</li>
<li><code>file_path</code>:      Path to file that should be parsed.</li>
<li><code>encoding</code>:       Encoding in file that is parsed.</li>
<li><code>parser_logger</code>:  Logging function that will be used by parser.</li>
<li><code>timer_logger</code>:   Logging function that will be used to log timing information.</li>
<li><code>use_cache</code>:      Whether to use a cache to avoid parsing the same file several times.</li>
<li><code>parser_args</code>:    Input arguments to the parser</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Parser</code>:  Parser with the parsed data</li>
</ul>
<h1 id="midgardparsers_parser">midgard.parsers._parser</h1>
<p>Basic functionality for parsing datafiles, extended by individual parsers</p>
<p><strong>Description:</strong></p>
<p>This module contains functions and classes for parsing datafiles. It should typically be used by calling
<code>parsers.parse_file</code>:</p>
<p><strong>Example:</strong></p>
<pre><code>from midgard import parsers
my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...)
my_data = my_new_parser.as_dict()
</code></pre>
<h2 id="parser"><strong>Parser</strong></h2>
<p>Full name: <code>midgard.parsers._parser.Parser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;) -&gt; None</code></p>
<p>An abstract base class that has basic methods for parsing a datafile</p>
<p>This class provides functionality for parsing a file. You should inherit from one of the specific parsers like for
instance ChainParser, LineParser, SinexParser etc</p>
<p><strong>Attributes:</strong></p>
<p>file_path (Path):             Path to the datafile that will be read.
file_encoding (String):       Encoding of the datafile.
parser_name (String):         Name of the parser (as needed to call parsers.parse_...).
data_available (Boolean):     Indicator of whether data are available.
data (Dict):                  The (observation) data read from file.
meta (Dict):                  Metainformation read from file.</p>
<h3 id="parseras_dataframe">Parser.<strong>as_dataframe</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.as_dataframe</code></p>
<p>Signature: <code>(self, index:Union[str, List[str], NoneType]=None) -&gt; pandas.core.frame.DataFrame</code></p>
<p>Return the parsed data as a Pandas DataFrame</p>
<p>This is a basic implementation, assuming the <code>self.data</code>-dictionary has
a simple structure. More advanced parsers may need to reimplement this
method.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>index</code>:  Optional name of field to use as index. May also be a list of strings.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Pandas DataFrame with the parsed data.</p>
<h3 id="parseras_dataset">Parser.<strong>as_dataset</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.as_dataset</code></p>
<p>Signature: <code>(self) -&gt; NoReturn</code></p>
<p>Return the parsed data as a Midgard Dataset</p>
<p>This is a basic implementation, assuming the <code>self.data</code>-dictionary has
a simple structure. More advanced parsers may need to reimplement this
method.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Dataset</code>:  The parsed data.</li>
</ul>
<h3 id="parseras_dict">Parser.<strong>as_dict</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.as_dict</code></p>
<p>Signature: <code>(self, include_meta:bool=False) -&gt; Dict[str, Any]</code></p>
<p>Return the parsed data as a dictionary</p>
<p>This is a basic implementation, simply returning a copy of
self.data. More advanced parsers may need to reimplement this method.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>include_meta</code>:  Whether to include meta-data in the returned dictionary (default: False).</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with the parsed data.</p>
<h3 id="parserparse">Parser.<strong>parse</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.parse</code></p>
<p>Signature: <code>(self) -&gt; 'Parser'</code></p>
<p>Parse data</p>
<p>This is a basic implementation that carries out the whole pipeline of
reading and parsing datafiles including calculating secondary data.</p>
<p>Subclasses should typically implement (at least) the <code>read_data</code>-method.</p>
<h3 id="parserpostprocess_data">Parser.<strong>postprocess_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.postprocess_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Do simple manipulations on the data after they are read</p>
<p>Simple manipulations of data may be performed in postprocessors after
they are read. They should be kept simple so that a parser returns as
true representation of the data file as possible. Advanced calculations
may be done inside apriori classes or similar.</p>
<p>To add a postprocessor, define it in its own method, and override the
<code>setup_postprocessors</code>-method to return a list of all postprocessors.</p>
<h3 id="parserread_data">Parser.<strong>read_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.read_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Read data from the data file</p>
<p>Data should be read from <code>self.file_path</code> and stored in the dictionary
<code>self.data</code>. A description of the data may be placed in the dictionary
<code>self.meta</code>. If data are not available for some reason,
<code>self.data_available</code> should be set to False.</p>
<h3 id="parsersetup_parser">Parser.<strong>setup_parser</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.setup_parser</code></p>
<p>Signature: <code>(self) -&gt; Any</code></p>
<p>Set up information needed for the parser</p>
<h3 id="parsersetup_postprocessors">Parser.<strong>setup_postprocessors</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.setup_postprocessors</code></p>
<p>Signature: <code>(self) -&gt; List[Callable[[], NoneType]]</code></p>
<p>List postprocessors that should be called after parsing</p>
<h3 id="parserupdate_dataset">Parser.<strong>update_dataset</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser.update_dataset</code></p>
<p>Signature: <code>(self, dset:Any) -&gt; NoReturn</code></p>
<p>Update the given dataset with the parsed data</p>
<p>This is a basic implementation, assuming the <code>self.data</code>-dictionary has
a simple structure. More advanced parsers may need to reimplement this
method.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>dset</code>:  The dataset to update with parsed data.</li>
</ul>
<h1 id="midgardparsers_parser_chain">midgard.parsers._parser_chain</h1>
<p>Basic functionality for parsing datafiles line by line</p>
<p><strong>Description:</strong></p>
<p>This module contains functions and classes for parsing datafiles.</p>
<p><strong>Example:</strong></p>
<pre><code>from midgard import parsers
my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...)
my_data = my_new_parser.as_dict()
</code></pre>
<h2 id="chainparser"><strong>ChainParser</strong></h2>
<p>Full name: <code>midgard.parsers._parser_chain.ChainParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;) -&gt; None</code></p>
<p>An abstract base class that has basic methods for parsing a datafile</p>
<p>This class provides functionality for parsing a file with chained groups of information. You should inherit from
this one, and at least specify the necessary parameters in <code>setup_parser</code>.</p>
<h3 id="chainparserparse_line">ChainParser.<strong>parse_line</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_chain.parse_line</code></p>
<p>Signature: <code>(self, line:str, cache:Dict[str, Any], parser:midgard.parsers._parser_chain.ParserDef) -&gt; None</code></p>
<p>Parse line</p>
<p>A line is parsed by separating a line in fields. How the separation is done, is defined in the <code>parser_def</code>
entry of the ParserDef.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>line</code>:    Line to be parsed.</li>
<li><code>cache</code>:   Store temporary data.</li>
<li><code>parser</code>:  Dictionary with defined parsers with the keys 'parser_def', 'label' and 'end_marker'.</li>
</ul>
<h3 id="chainparserread_data">ChainParser.<strong>read_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_chain.read_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Read data from a data file and parse the contents</p>
<h3 id="chainparsersetup_parser">ChainParser.<strong>setup_parser</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_chain.setup_parser</code></p>
<p>Signature: <code>(self) -&gt; Any</code></p>
<p>Set up information needed for the parser</p>
<p>Return an iterable of ParserDef's that describe the structure of the file that will be parsed</p>
<h2 id="parserdef"><strong>ParserDef</strong></h2>
<p>Full name: <code>midgard.parsers._parser_chain.ParserDef</code></p>
<p>Signature: <code>(end_marker:Callable[[str, int, str], bool], label:Callable[[str, int], str], parser_def:Dict[str, Dict[str, Any]], skip_line:Union[Callable[[str], bool], NoneType]=None, end_callback:Union[Callable[[Dict[str, Any]], NoneType], NoneType]=None)</code></p>
<p>A convenience class for defining the necessary fields of a parser</p>
<p>A single parser can read and parse one group of datalines, defined through the ParserDef by specifying how to parse
each line (parser_def), how to identify each line (label), how to recognize the end of the group of lines
(end_marker) and finally what (if anything) should be done after all lines in a group is read (end_callback).</p>
<p>The end_marker, label, skip_line and end_callback parameters should all be functions with the following signatures:</p>
<pre><code>end_marker   = func(line, line_num, next_line)
label        = func(line, line_num)
skip_line    = func(line)
end_callback = func(cache)
</code></pre>
<p>The parser definition <code>parser_def</code> includes the <code>parser</code>, <code>field</code>, <code>strip</code> and <code>delimiter</code> entries. The <code>parser</code>
entry points to the parser function and the <code>field</code> entry defines how to separate the line in fields. The separated
fields are saved either in a dictionary or in a list. In the last case the line is split on whitespace by
default. With the <code>delimiter</code> entry the default definition can be overwritten. Leading and trailing whitespace
characters are removed by default before a line is parsed.  This default can be overwritten by defining the
characters, which should be removed with the 'strip' entry. The <code>parser</code> dictionary is defined like:</p>
<pre><code>parser_def = { &lt;label&gt;: {'fields':    &lt;dict or list of fields&gt;,
                         'parser':    &lt;parser function&gt;,
                         'delimiter': &lt;optional delimiter for splitting line&gt;,
                         'strip':     &lt;optional characters to be removed from beginning and end of line&gt;
             }}
</code></pre>
<p><strong>Args:</strong></p>
<ul>
<li><code>end_marker</code>:   A function returning True for the last line in a group.</li>
<li><code>label</code>:        A function returning a label used in the parser_def.</li>
<li><code>parser_def</code>:   A dict with 'parser' and 'fields' defining the parser.</li>
<li><code>skip_line</code>:    A function returning True if the line should be skipped.</li>
<li><code>end_callback</code>: A function called after reading all lines in a group.</li>
</ul>
<h1 id="midgardparsers_parser_line">midgard.parsers._parser_line</h1>
<p>Basic functionality for parsing datafiles line by line using Numpy</p>
<p><strong>Description:</strong></p>
<p>This module contains functions and classes for parsing datafiles.</p>
<p><strong>Example:</strong></p>
<pre><code>from midgard import parsers
my_new_parser = parsers.parse_file('my_new_parser', 'file_name.txt', ...)
my_data = my_new_parser.as_dict()
</code></pre>
<h2 id="lineparser"><strong>LineParser</strong></h2>
<p>Full name: <code>midgard.parsers._parser_line.LineParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;) -&gt; None</code></p>
<p>An abstract base class that has basic methods for parsing a datafile</p>
<p>This class provides functionality for using numpy to parse a file line by line. You should inherit from this one,
and at least specify the necessary parameters in <code>setup_parser</code>.</p>
<h3 id="lineparserread_data">LineParser.<strong>read_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_line.read_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Read data from the data file</p>
<p>Uses the np.genfromtxt-function to parse the file. Any necessary
parameters should be set by <code>setup_parser</code>. Override
<code>self.structure_data</code> if the self.data-dictionary needs to be
structured in a particular way.</p>
<h3 id="lineparsersetup_parser">LineParser.<strong>setup_parser</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_line.setup_parser</code></p>
<p>Signature: <code>(self) -&gt; Any</code></p>
<p>Set up information needed for the parser</p>
<p>This method should return a dictionary which contains all parameters
needed by np.genfromtxt to do the actual parsing.</p>
<h3 id="lineparserstructure_data">LineParser.<strong>structure_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_line.structure_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Structure raw array data into the self.data dictionary</p>
<p>This simple implementation creates a dictionary with one item per column in the array. Override this method for
more complex use cases.</p>
<h1 id="midgardparsers_parser_rinex">midgard.parsers._parser_rinex</h1>
<p>Basic functionality for parsing Rinex files</p>
<p><strong>Description:</strong></p>
<p>This module contains functions and classes for parsing Rinex files.</p>
<p>This file defines the general structure shared by most types of Rinex files, including header information. More
specific format details are implemented in subclasses. When calling the parser, you should call the apropriate parser
for a given Rinex format.</p>
<h2 id="rinexheader"><strong>RinexHeader</strong></h2>
<p>Full name: <code>midgard.parsers._parser_rinex.RinexHeader</code></p>
<p>Signature: <code>(marker:str, fields:Dict[str, Tuple[int, int]], parser:Callable[[Dict[str, str]], Dict[str, Any]])</code></p>
<p>A convenience class for defining how a Rinex header is parsed</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>marker</code>:  Marker of header (as defined in columns 60 and onward).</li>
<li><code>fields</code>:  Dictionary with field names as keys, tuple of start- and end-columns as value.</li>
<li><code>parser</code>:  Function that will parse the fields.</li>
</ul>
<h2 id="rinexparser"><strong>RinexParser</strong></h2>
<p>Full name: <code>midgard.parsers._parser_rinex.RinexParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;, strict:bool=False) -&gt; None</code></p>
<p>An abstract base class that has basic methods for parsing a datafile</p>
<p>This class provides functionality for reading Rinex header data. You should inherit from this one,
and at least implement <code>parse_epochs</code>.</p>
<h3 id="rinexparserget_rinex_version">RinexParser.<strong>get_rinex_version</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.get_rinex_version</code></p>
<p>Signature: <code>(self) -&gt; str</code></p>
<p>Get version of Rinex file</p>
<h3 id="rinexparsername-str">RinexParser.name (str)</h3>
<p><code>name = 'Rinex'</code></p>
<h3 id="rinexparserparse_approx_position">RinexParser.<strong>parse_approx_position</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_approx_position</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse station coordinates defined in RINEX header to instance variable <code>data</code></p>
<h3 id="rinexparserparse_comment">RinexParser.<strong>parse_comment</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_comment</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse comment lines in RINEX header to instance variable <code>header['comment']</code></p>
<h3 id="rinexparserparse_data_lines">RinexParser.<strong>parse_data_lines</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_data_lines</code></p>
<p>Signature: <code>(self, lines, epoch_info)</code></p>
<h3 id="rinexparserparse_epoch_line">RinexParser.<strong>parse_epoch_line</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_epoch_line</code></p>
<p>Signature: <code>(self, line)</code></p>
<h3 id="rinexparserparse_float">RinexParser.<strong>parse_float</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_float</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse float entries of RINEX header to instance variable <code>header</code></p>
<h3 id="rinexparserparse_glonass_code_phase_bias">RinexParser.<strong>parse_glonass_code_phase_bias</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_glonass_code_phase_bias</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse GLONASS phase correction in RINEX header to instance variable <code>header['glonass_bias']</code></p>
<p>self.header['glonass_bias'] = { <obstype>: <bias in meters>}</p>
<h3 id="rinexparserparse_glonass_slot">RinexParser.<strong>parse_glonass_slot</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_glonass_slot</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse GLONASS slot and frequency numbers given in RINEX header to instance variable <code>header['glonass_slot']</code></p>
<p>self.header['glonass_slot'] = { <slot>: <frequency number>}</p>
<h3 id="rinexparserparse_integer">RinexParser.<strong>parse_integer</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_integer</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse integer entries of RINEX header to instance variable <code>header</code></p>
<h3 id="rinexparserparse_leap_seconds">RinexParser.<strong>parse_leap_seconds</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_leap_seconds</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse entries of RINEX header <code>LEAP SECONDS</code> to instance variable <code>header</code></p>
<p>self.header['leap_seconds'] = { 'leap_seconds': <value>,
                                'future_past_leap_seconds': <value>,
                                'week': <value>,
                                'week_day': <value>,
                                'time_sys': <system> }</p>
<h3 id="rinexparserparse_phase_shift">RinexParser.<strong>parse_phase_shift</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_phase_shift</code></p>
<p>Signature: <code>(self, fields:Dict[str, str], cache:List[Dict[str, str]]) -&gt; Dict[str, Any]</code></p>
<p>Parse entries of RINEX header <code>SYS / PHASE SHIFT</code> to instance variable <code>header</code></p>
<pre><code>self.header['phase_shift'] = { &lt;sat_sys&gt;: { &lt;obs_type&gt;: { corr: &lt;correction&gt;,
                                                        sat: &lt;[satellite list]&gt;}}}
</code></pre>
<p>Example of <code>phase_shift</code> header entry:</p>
<pre><code>self.header['phase_shift'] =  {'G': {'L1C': {'corr': '0.00000',
                                           'sat': ['G01', 'G02', 'G03', ...]},
                                     'L1W': {'corr': '0.00000',
                                           'sat': []}},
                              'R': {'L1C': {'corr': '0.00000',
                                           'sat': ['R01', 'R02', 'R07', 'R08']}}}
</code></pre>
<p>TODO: Maybe better to add information to header['obstypes']?</p>
<h3 id="rinexparserparse_scale_factor">RinexParser.<strong>parse_scale_factor</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_scale_factor</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse entries of RINEX header <code>SYS / SCALE FACTOR</code> to instance variable <code>header</code></p>
<h3 id="rinexparserparse_string">RinexParser.<strong>parse_string</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_string</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse string entries of RINEX header to instance variable 'header'</p>
<h3 id="rinexparserparse_sys_dcbs_applied">RinexParser.<strong>parse_sys_dcbs_applied</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_sys_dcbs_applied</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse entries of RINEX header <code>SYS / DCBS APPLIED</code> to instance variable <code>header</code></p>
<p>self.header['dcbs_applied'] = { <sat_sys>: { prg: <used program>,
                                             url: <source url>}}</p>
<h3 id="rinexparserparse_sys_obs_types">RinexParser.<strong>parse_sys_obs_types</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_sys_obs_types</code></p>
<p>Signature: <code>(self, fields:Dict[str, str], cache:List[Dict[str, str]]) -&gt; Dict[str, Any]</code></p>
<p>Parse observation types given in RINEX header to instance variable <code>header['obstypes']</code> and data</p>
<p>The data dictionaries <code>obs</code>, <code>cycle_slip</code> and <code>signal_strength</code> are initialized based on the given observation
type in the RINEX header.</p>
<pre><code>self.header['obstypes'] = { &lt;sat_sys&gt;: [&lt;ordered list with given observation types&gt;]}
</code></pre>
<h3 id="rinexparserparse_sys_pcvs_applied">RinexParser.<strong>parse_sys_pcvs_applied</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_sys_pcvs_applied</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse entries of RINEX header <code>SYS / PCVS APPLIED</code> to instance variable <code>header</code></p>
<p>self.header['pcvs_applied'] = { <sat_sys>: { prg: <used program>,
                                           url: <source url>}}</p>
<h3 id="rinexparserparse_time_of_first_obs">RinexParser.<strong>parse_time_of_first_obs</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_time_of_first_obs</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse time of first observation given in RINEX header to instance variable <code>header</code></p>
<h3 id="rinexparserparse_time_of_last_obs">RinexParser.<strong>parse_time_of_last_obs</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.parse_time_of_last_obs</code></p>
<p>Signature: <code>(self, fields:Dict[str, str]) -&gt; Dict[str, Any]</code></p>
<p>Parse time of last observation given in RINEX header to instance variable <code>header</code></p>
<h3 id="rinexparserread_data">RinexParser.<strong>read_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.read_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Read data from the data file</p>
<h3 id="rinexparserread_epochs">RinexParser.<strong>read_epochs</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.read_epochs</code></p>
<p>Signature: <code>(self, fid) -&gt; None</code></p>
<p>Read data from Rinex file</p>
<p>Add data to self.data</p>
<h3 id="rinexparserread_header">RinexParser.<strong>read_header</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.read_header</code></p>
<p>Signature: <code>(self, fid) -&gt; None</code></p>
<p>Read header from the rinex file</p>
<p>Add header information to self.header</p>
<h3 id="rinexparserstructure_data">RinexParser.<strong>structure_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_rinex.structure_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Convert lists of data to numpy arrays</p>
<h2 id="parser_cache"><strong>parser_cache</strong>()</h2>
<p>Full name: <code>midgard.parsers._parser_rinex.parser_cache</code></p>
<p>Signature: <code>(func:Callable[[_ForwardRef('RinexParser'), Dict[str, str], List[Dict[str, str]]], Dict[str, Any]]) -&gt; Callable[[_ForwardRef('RinexParser'), Dict[str, str]], Dict[str, Any]]</code></p>
<p>Decorator for adding a cache to parser functions</p>
<h1 id="midgardparsers_parser_sinex">midgard.parsers._parser_sinex</h1>
<p>Basic functionality for parsing Sinex datafiles</p>
<p><strong>Description:</strong></p>
<p>This module contains functions and classes for parsing Sinex datafiles.</p>
<p><strong>References:</strong></p>
<ul>
<li>SINEX Format: https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html</li>
</ul>
<h2 id="sinexblock"><strong>SinexBlock</strong></h2>
<p>Full name: <code>midgard.parsers._parser_sinex.SinexBlock</code></p>
<p>Signature: <code>(marker:str, fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...], parser:Callable[[&lt;built-in function array&gt;, Tuple[str, ...]], Dict[str, Any]])</code></p>
<p>A convenience class for defining a Sinex block</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>marker</code>:  Sinex marker denoting the block.</li>
<li><code>fields</code>:  Fields in Sinex block.</li>
<li><code>parser</code>:  Function used to parse the data.</li>
</ul>
<h2 id="sinexfield"><strong>SinexField</strong></h2>
<p>Full name: <code>midgard.parsers._parser_sinex.SinexField</code></p>
<p>Signature: <code>(name:str, start_col:int, dtype:Union[str, NoneType], converter:Union[str, NoneType]=None)</code></p>
<p>A convenience class for defining the fields in a Sinex block</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>name</code>:       Name of field.</li>
<li><code>start_col</code>:  Starting column of field (First column is 0)</li>
<li><code>dtype</code>:      String, using numpy notation, defining type of field, use None to ignore field.</li>
<li><code>converter</code>:  Optional, name of converter to apply to field data.</li>
</ul>
<h2 id="sinexparser"><strong>SinexParser</strong></h2>
<p>Full name: <code>midgard.parsers._parser_sinex.SinexParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=None, header:bool=True) -&gt; None</code></p>
<p>An abstract base class that has basic methods for parsing a Sinex file</p>
<p>This class provides functionality for parsing a sinex file with chained
groups of information. You should inherit from this one, and at least
specify which Sinex blocks you are interested in by implementing
<code>setup_parser</code>, as well as implement methods that parse each block if
needed.</p>
<h3 id="sinexparseras_dataframe">SinexParser.<strong>as_dataframe</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.as_dataframe</code></p>
<p>Signature: <code>(self, index:Union[str, List[str], NoneType]=None, marker:Union[str, NoneType]=None) -&gt; pandas.core.frame.DataFrame</code></p>
<p>Return the parsed data as a Pandas DataFrame</p>
<p>This is a basic implementation, assuming the <code>self.data</code>-dictionary has
a simple structure. More advanced parsers may need to reimplement this
method.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>marker</code>:  Only return data from this marker in the DataFrame.</li>
<li><code>index</code>:   Name of field to use as index. May also be a list of strings.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Pandas DataFrame with the parsed data.</p>
<h3 id="sinexparserparse_bias_epochs">SinexParser.<strong>parse_bias_epochs</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_bias_epochs</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_blocks">SinexParser.<strong>parse_blocks</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_blocks</code></p>
<p>Signature: <code>(self, fid:Iterable[bytes]) -&gt; None</code></p>
<p>Parse contents of Sinex blocks</p>
<p>Contents of Sinex blocks are stored as separate numpy-arrays in
self._sinex</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>fid</code>:  Pointer to file being read.</li>
</ul>
<h3 id="sinexparserparse_file_comment">SinexParser.<strong>parse_file_comment</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_file_comment</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_file_reference">SinexParser.<strong>parse_file_reference</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_file_reference</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_header_line">SinexParser.<strong>parse_header_line</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_header_line</code></p>
<p>Signature: <code>(self, header_line:bytes) -&gt; None</code></p>
<p>Parse header of Sinex file</p>
<p>Header information is stored in <code>self.meta</code>.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>header_line</code>:  First line of Sinex file.</li>
</ul>
<h3 id="sinexparserparse_input_acknowledgements">SinexParser.<strong>parse_input_acknowledgements</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_input_acknowledgements</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_input_files">SinexParser.<strong>parse_input_files</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_input_files</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_input_history">SinexParser.<strong>parse_input_history</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_input_history</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_lines">SinexParser.<strong>parse_lines</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_lines</code></p>
<p>Signature: <code>(self, lines:List[bytes], fields:Tuple[midgard.parsers._parser_sinex.SinexField, ...]) -&gt; &lt;built-in function array&gt;</code></p>
<p>Parse lines in a Sinex file</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>lines</code>:   Lines to parse.</li>
<li><code>fields</code>:  Definition of sinex fields in lines.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Data contained in lines.</p>
<h3 id="sinexparserparse_nutation_data">SinexParser.<strong>parse_nutation_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_nutation_data</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_precession_data">SinexParser.<strong>parse_precession_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_precession_data</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_satellite_id">SinexParser.<strong>parse_satellite_id</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_satellite_id</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_satellite_phase_center">SinexParser.<strong>parse_satellite_phase_center</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_satellite_phase_center</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_site_antenna">SinexParser.<strong>parse_site_antenna</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_site_antenna</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_site_data">SinexParser.<strong>parse_site_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_site_data</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_site_eccentricity">SinexParser.<strong>parse_site_eccentricity</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_site_eccentricity</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_site_gal_phase_center">SinexParser.<strong>parse_site_gal_phase_center</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_site_gal_phase_center</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_site_gps_phase_center">SinexParser.<strong>parse_site_gps_phase_center</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_site_gps_phase_center</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_site_id">SinexParser.<strong>parse_site_id</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_site_id</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_site_receiver">SinexParser.<strong>parse_site_receiver</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_site_receiver</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_solution_apriori">SinexParser.<strong>parse_solution_apriori</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_apriori</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_solution_epochs">SinexParser.<strong>parse_solution_epochs</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_epochs</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_solution_estimate">SinexParser.<strong>parse_solution_estimate</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_estimate</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_solution_matrix_apriori">SinexParser.<strong>parse_solution_matrix_apriori</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_matrix_apriori</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, lower_upper:str, type:str='') -&gt; Dict[str, Any]</code></p>
<p>Parser for SOLUTION/MATRIX_APRIORI data</p>
<p>Converts the input data to a symmetric matrix and adds it to
self.data['SOLUTION/MATRIX_APRIORI'].</p>
<p>The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters
Index in the SOLUTION/ESTIMATE block.  Missing elements in the matrix are
assumed to be zero (0); consequently, zero elements may be omitted to
reduce the size of this block.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:         Input data, raw data for SOLUTION/MATRIX_APRIORI block.</li>
<li><code>lower_upper</code>:  Either 'L' or 'U', indicating whether the matrix is given in lower or upper form.</li>
<li><code>type</code>:         Information about the type of matrix, optional.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with symmetric matrix as a numpy array.</p>
<h3 id="sinexparserparse_solution_matrix_estimate">SinexParser.<strong>parse_solution_matrix_estimate</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_matrix_estimate</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, lower_upper:str, type:str='') -&gt; Dict[str, Any]</code></p>
<p>Parser for SOLUTION/MATRIX_ESTIMATE data</p>
<p>Converts the input data to a symmetric matrix and adds it to
self.data['SOLUTION/MATRIX_ESTIMATE'].</p>
<p>The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters
Index in the SOLUTION/ESTIMATE block.  Missing elements in the matrix are
assumed to be zero (0); consequently, zero elements may be omitted to
reduce the size of this block.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:         Input data, raw data for SOLUTION/MATRIX_ESTIMATE block.</li>
<li><code>lower_upper</code>:  Either 'L' or 'U', indicating whether the matrix is given in lower or upper form.</li>
<li><code>type</code>:         Information about the type of matrix, optional.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with symmetric matrix as a numpy array.</p>
<h3 id="sinexparserparse_solution_normal_equation_matrix">SinexParser.<strong>parse_solution_normal_equation_matrix</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_normal_equation_matrix</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, lower_upper:str, type:str='') -&gt; Dict[str, Any]</code></p>
<p>Parser for SOLUTION/NORMAL_EQUATION_MATRIX data</p>
<p>Converts the input data to a symmetric matrix and adds it to
self.data['SOLUTION/NORMAL_EQUATION_MATRIX'].</p>
<p>The NEQ-Matrix Row/Column Number correspond to the Estimated Parameters
Index in the SOLUTION/ESTIMATE block.  Missing elements in the matrix are
assumed to be zero (0); consequently, zero elements may be omitted to
reduce the size of this block.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:         Input data, raw data for SOLUTION/NORMAL_EQUATION_MATRIX block.</li>
<li><code>lower_upper</code>:  Either 'L' or 'U', indicating whether the matrix is given in lower or upper form.</li>
<li><code>type</code>:         Information about the type of matrix, optional.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with symmetric matrix as a numpy array.</p>
<h3 id="sinexparserparse_solution_normal_equation_vector">SinexParser.<strong>parse_solution_normal_equation_vector</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_normal_equation_vector</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_solution_statistics">SinexParser.<strong>parse_solution_statistics</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_solution_statistics</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserparse_source_id">SinexParser.<strong>parse_source_id</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.parse_source_id</code></p>
<p>Signature: <code>(self:'SinexParser', data:&lt;built-in function array&gt;, *params:str) -&gt; Dict[str, Any]</code></p>
<p>Simple parser for Sinex data</p>
<p>Converts the input data to a dictionary of numpy arrays and returns it
in order to add it to self.data['{marker}']. Ignores any block title
parameters.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>data</code>:    Input data, raw data for the block.</li>
<li><code>params</code>:  Tuple of strings with parameters given after the marker at the start of the block.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with each column in the Sinex file as a numpy array.</p>
<h3 id="sinexparserread_data">SinexParser.<strong>read_data</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.read_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Read data from a Sinex file and parse the contents</p>
<p>First the whole Sinex file is read and the requested blocks are stored
in self._sinex. After the file has been read, a parser is called on
each block so that self.data is properly populated.</p>
<h3 id="sinexparsersetup_parser">SinexParser.<strong>setup_parser</strong>()</h3>
<p>Full name: <code>midgard.parsers._parser_sinex.setup_parser</code></p>
<p>Signature: <code>(self) -&gt; Any</code></p>
<p>Set up information needed for the parser</p>
<p>Each individual Sinex-parser should at least implement this method.</p>
<p>If the order the blocks are parsed is not important, the information
should be returned as a set for optimal performance. If the parsing
order is important, a tuple of SinexBlock-objects may be returned
instead.</p>
<p><strong>Returns:</strong></p>
<p>Iterable of blocks in the Sinex file that should be parsed.</p>
<h2 id="parsing_factory"><strong>parsing_factory</strong>()</h2>
<p>Full name: <code>midgard.parsers._parser_sinex.parsing_factory</code></p>
<p>Signature: <code>() -&gt; Callable[..., Dict[str, Any]]</code></p>
<p>Create a default parsing function for a Sinex block</p>
<p>The default parsing function returns a dictionary containing all fields of
the block as separated arrays. This will be stored in self.data['{marker}']
with the {marker} of the current block.</p>
<p><strong>Returns:</strong></p>
<p>Simple parsing function for one Sinex block.</p>
<h2 id="parsing_matrix_factory"><strong>parsing_matrix_factory</strong>()</h2>
<p>Full name: <code>midgard.parsers._parser_sinex.parsing_matrix_factory</code></p>
<p>Signature: <code>(marker:str, size_marker:str) -&gt; Callable[..., Dict[str, Any]]</code></p>
<p>Create a parsing function for parsing a matrix within a Sinex block</p>
<p>The default parsing function converts data to a symmetric matrix and stores
it inside <code>self.data[marker]</code>.</p>
<p>The size of the matrix is set to equal the number of parameters in the
<code>size_marker</code>-block. If that block is not parsed/found. The size is set to
the last given row index. If some zero elements in the matrix are omitted
this might be wrong.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>marker</code>:       Marker of Sinex block.</li>
<li><code>size_marker</code>:  Marker of a different Sinex block indicating the size of the matrix.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Simple parsing function for one Sinex block.</p>
<h1 id="midgardparsersgalileo_constellation_html">midgard.parsers.galileo_constellation_html</h1>
<p>A parser for reading IVS source names translation table</p>
<h2 id="galileoconstellationhtmlparser"><strong>GalileoConstellationHTMLParser</strong></h2>
<p>Full name: <code>midgard.parsers.galileo_constellation_html.GalileoConstellationHTMLParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;, url:Union[str, NoneType]=None) -&gt; None</code></p>
<p>A parser for reading Galileo constellation info from a web page</p>
<p>See https://www.gsc-europa.eu/system-status/Constellation-Information for an example</p>
<h3 id="galileoconstellationhtmlparserurl-str">GalileoConstellationHTMLParser.URL (str)</h3>
<p><code>URL = 'https://www.gsc-europa.eu/system-status/Constellation-Information'</code></p>
<h3 id="galileoconstellationhtmlparserdownload_html">GalileoConstellationHTMLParser.<strong>download_html</strong>()</h3>
<p>Full name: <code>midgard.parsers.galileo_constellation_html.download_html</code></p>
<p>Signature: <code>(self, url:Union[str, NoneType]=None) -&gt; None</code></p>
<p>Download html file from url</p>
<p>TODO: Move this to files/url.py</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>url</code>:  URL to download from, if None use self.URL instead.</li>
</ul>
<h3 id="galileoconstellationhtmlparserread_data">GalileoConstellationHTMLParser.<strong>read_data</strong>()</h3>
<p>Full name: <code>midgard.parsers.galileo_constellation_html.read_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Read tables from the HTML file</p>
<p>The satellite table is placed in self.data, while the NAGU events are placed in self.meta["events"].</p>
<h3 id="galileoconstellationhtmlparsersatellite_id">GalileoConstellationHTMLParser.<strong>satellite_id</strong>()</h3>
<p>Full name: <code>midgard.parsers.galileo_constellation_html.satellite_id</code></p>
<p>Signature: <code>(self, sat_id:str) -&gt; Dict[str, Any]</code></p>
<p>Get satellite info from satellite vehicle ID</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>sat_id</code>:  ID of satellite, for example E01.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with satellite info.</p>
<h3 id="galileoconstellationhtmlparsersatellite_name">GalileoConstellationHTMLParser.<strong>satellite_name</strong>()</h3>
<p>Full name: <code>midgard.parsers.galileo_constellation_html.satellite_name</code></p>
<p>Signature: <code>(self, sat_name:str) -&gt; Dict[str, Any]</code></p>
<p>Get satellite info from name</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>sat_name</code>:  Name of satellite, for example GSAT0101.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary with satellite info.</p>
<h1 id="midgardparsersgnss_antex">midgard.parsers.gnss_antex</h1>
<p>A parser for reading ANTEX format 1.4 data</p>
<p><strong>Example:</strong></p>
<pre><code>from midgard import parsers
p = parsers.parse_file(parser_name='gnss_antex', file_path='igs14.atx')
data = p.as_dict()
</code></pre>
<p><strong>Description:</strong></p>
<p>Reads data from files in the GNSS Antenna Exchange (ANTEX) file format version 1.4 (see :cite:<code>antex</code>).</p>
<h2 id="antexparser"><strong>AntexParser</strong></h2>
<p>Full name: <code>midgard.parsers.gnss_antex.AntexParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;) -&gt; None</code></p>
<p>A parser for reading ANTEX file</p>
<p>The parser reads GNSS ANTEX format 1.4 (see :cite:<code>antex</code>).</p>
<p>The 'data' attribute is a dictionary with GNSS satellite PRN or receiver antenna as key. The GNSS satellite
antenna corrections are time dependent and saved with "valid from" datetime object entry. The dictionary looks
like:</p>
<pre><code>dout = { &lt;prn&gt; : {&lt;valid from&gt;: { cospar_id:   &lt;value&gt;,
                                   sat_code:    &lt;value&gt;,
                                   sat_type:    &lt;value&gt;,
                                   valid_until: &lt;value&gt;,
                                   azimuth:     &lt;list with azimuth values&gt;,
                                   elevation:   &lt;list with elevation values&gt;,
                                   &lt;frequency&gt;: { azi: [&lt;list with azimuth-elevation dependent corrections&gt;],
                                                  neu: [north, east, up],
                                                  noazi: [&lt;list with elevation dependent corrections&gt;] }}},

         &lt;receiver antenna&gt; : {azimuth:     &lt;list with azimuth values&gt;,
                                elevation:   &lt;list with elevation values&gt;,
                                &lt;frequency&gt;: { azi: [&lt;array with azimuth-elevation dependent corrections&gt;],
                                               neu: [north, east, up],
                                               noazi: [&lt;list with elevation dependent corrections&gt;] }}}
</code></pre>
<p>with following entries:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>azi</td>
<td>numpy.ndarray</td>
<td>Array with azimuth-elevation dependent antenna correction in [mm] with</td>
</tr>
<tr>
<td></td>
<td></td>
<td>the shape: number of azimuth values x number of elevation values.</td>
</tr>
<tr>
<td>azimuth</td>
<td>numpy.ndarray</td>
<td>List with azimuth values in [rad] corresponding to antenna corrections</td>
</tr>
<tr>
<td></td>
<td></td>
<td>given in <code>azi</code>.</td>
</tr>
<tr>
<td>cospar_id</td>
<td>str</td>
<td>COSPAR ID <yyyy-xxxa>: yyyy -&gt; year when the satellite was put in</td>
</tr>
<tr>
<td></td>
<td></td>
<td>orbit, xxx -&gt; sequential satellite number for that year, a -&gt; alpha</td>
</tr>
<tr>
<td></td>
<td></td>
<td>numeric sequence number within a launch</td>
</tr>
<tr>
<td>elevation</td>
<td>numpy.ndarray</td>
<td>List with elevation values in [rad] corresponding to antenna</td>
</tr>
<tr>
<td></td>
<td></td>
<td>corrections given in <code>azi</code> or <code>noazi</code>.</td>
</tr>
<tr>
<td><frequency></td>
<td>str</td>
<td>Frequency identifier (e.g. G01 - GPS L1)</td>
</tr>
<tr>
<td>neu</td>
<td>list</td>
<td>North, East and Up eccentricities in [m]. The eccentricities of the</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mean antenna phase center is given relative to the antenna reference</td>
</tr>
<tr>
<td></td>
<td></td>
<td>point (ARP) for receiver antennas or to the center of mass of the</td>
</tr>
<tr>
<td></td>
<td></td>
<td>satellite in X-, Y- and Z-direction.</td>
</tr>
<tr>
<td>noazi</td>
<td>numpy.ndarray</td>
<td>List with elevation dependent (non-azimuth-dependent) antenna</td>
</tr>
<tr>
<td></td>
<td></td>
<td>correction in [mm].</td>
</tr>
<tr>
<td><prn></td>
<td>str</td>
<td>Satellite code e.g. GPS PRN, GLONASS slot or Galileo SVID number</td>
</tr>
<tr>
<td><receiver antenna></td>
<td>str</td>
<td>Receiver antenna name together with radome code</td>
</tr>
<tr>
<td>sat_code</td>
<td>str</td>
<td>Satellite code e.g. GPS SVN, GLONASS number or Galileo GSAT number</td>
</tr>
<tr>
<td>sat_type</td>
<td>str</td>
<td>Satellite type (e.g. BLOCK IIA)</td>
</tr>
<tr>
<td>valid_from</td>
<td>datetime.datetime</td>
<td>Start of validity period of satellite in GPS time</td>
</tr>
<tr>
<td>valid_until</td>
<td>datetime.datetime</td>
<td>End of validity period of satellite in GPS time</td>
</tr>
</tbody>
</table>
<p>The 'meta' attribute is a dictionary with following entries:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>comment</td>
<td>list</td>
<td>Header commments given in list line by line</td>
</tr>
<tr>
<td>pcv_type</td>
<td>str</td>
<td>Phase center variation type</td>
</tr>
<tr>
<td>ref_antenna</td>
<td>str</td>
<td>Reference antenna type for relative antenna</td>
</tr>
<tr>
<td>ref_serial_num</td>
<td>str</td>
<td>Serial number of the reference antenna</td>
</tr>
<tr>
<td>sat_sys</td>
<td>str</td>
<td>Satellite system</td>
</tr>
<tr>
<td>version</td>
<td>str</td>
<td>Format version</td>
</tr>
</tbody>
</table>
<p><strong>Attributes:</strong></p>
<ul>
<li><code>data</code>:            (dict), Contains the (observation) data read from file.</li>
<li><code>data_available</code>:  (bool), Indicator of whether data are available.</li>
<li><code>file_path</code>:       (pathlib.Path), File path.</li>
<li><code>parser_name</code>:     (str), Parser name.</li>
<li><code>meta</code>:            (dict), Contains metainformation read from file.</li>
</ul>
<h3 id="antexparserparse_comment">AntexParser.<strong>parse_comment</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_comment</code></p>
<p>Signature: <code>(self, line:Dict[str, str], _:Dict[str, Any]) -&gt; None</code></p>
<p>Parse comment lines in ANTEX header.</p>
<h3 id="antexparserparse_correction">AntexParser.<strong>parse_correction</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_correction</code></p>
<p>Signature: <code>(self, line:Dict[str, str], cache:Dict[str, Any]) -&gt; None</code></p>
<p>Parse antenna corrections entries of ANTEX antenna section.</p>
<h3 id="antexparserparse_default_meta">AntexParser.<strong>parse_default_meta</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_default_meta</code></p>
<p>Signature: <code>(self, line:Dict[str, str], _:Dict[str, Any]) -&gt; None</code></p>
<p>Add the contents of line to meta</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>line</code>: Dict containing the fields of a line.</li>
</ul>
<h3 id="antexparserparse_num_of_frequencies">AntexParser.<strong>parse_num_of_frequencies</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_num_of_frequencies</code></p>
<p>Signature: <code>(self, line:Dict[str, str], cache:Dict[str, Any]) -&gt; None</code></p>
<p>Parse '# OF FREQUENCIES' entry of ANTEX antenna section.</p>
<h3 id="antexparserparse_section_float">AntexParser.<strong>parse_section_float</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_section_float</code></p>
<p>Signature: <code>(self, line:Dict[str, str], cache:Dict[str, Any]) -&gt; None</code></p>
<p>Parse float entries of ANTEX header.</p>
<h3 id="antexparserparse_section_string">AntexParser.<strong>parse_section_string</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_section_string</code></p>
<p>Signature: <code>(self, line:Dict[str, str], cache:Dict[str, Any]) -&gt; None</code></p>
<p>Parse string entries of ANTEX header.</p>
<h3 id="antexparserparse_string">AntexParser.<strong>parse_string</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_string</code></p>
<p>Signature: <code>(self, line:Dict[str, str], _:Dict[str, Any]) -&gt; None</code></p>
<p>Parse string entries of ANTEX header.</p>
<h3 id="antexparserparse_valid_from">AntexParser.<strong>parse_valid_from</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_valid_from</code></p>
<p>Signature: <code>(self, line:Dict[str, str], cache:Dict[str, Any]) -&gt; None</code></p>
<p>Parse 'VALID FROM' entries of ANTEX antenna section.</p>
<h3 id="antexparserparse_valid_until">AntexParser.<strong>parse_valid_until</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.parse_valid_until</code></p>
<p>Signature: <code>(self, line:Dict[str, str], cache:Dict[str, Any]) -&gt; None</code></p>
<p>Parse 'VALID UNTIL' entries of ANTEX antenna section.</p>
<h3 id="antexparsersave_correction">AntexParser.<strong>save_correction</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.save_correction</code></p>
<p>Signature: <code>(self, line:Dict[str, str], cache:Dict[str, Any]) -&gt; None</code></p>
<p>Save antenna correction in data structures.</p>
<p>The antenna corrections are saved after reading of corrections for one frequency. Antenna correction data are
saved in following data structure, whereby satellite antenna corrections are time dependent:</p>
<pre><code>self.data = { &lt;prn&gt; : {&lt;valid from&gt;: { cospar_id:   &lt;value&gt;,
                                        sat_code:    &lt;value&gt;,
                                        sat_type:    &lt;value&gt;,
                                        valid_until: &lt;value&gt;,
                                        azimuth:     &lt;list with azimuth values&gt;,
                                        elevation:   &lt;list with elevation values&gt;,
                                        &lt;frequency&gt;: { azi: [&lt;list with azimuth-elevation dependent corrections&gt;],
                                                       neu: [north, east, up],
                                                       noazi: [&lt;list with elevation dependent corrections&gt;] }}},

              &lt;receiver antenna&gt; : {azimuth:     &lt;list with azimuth values&gt;,
                                     elevation:   &lt;list with elevation values&gt;,
                                     &lt;frequency&gt;: { azi: [&lt;array with azimuth-elevation dependent corrections&gt;],
                                                    neu: [north, east, up],
                                                    noazi: [&lt;list with elevation dependent corrections&gt;] }}
            }
</code></pre>
<h3 id="antexparsersetup_parser">AntexParser.<strong>setup_parser</strong>()</h3>
<p>Full name: <code>midgard.parsers.gnss_antex.setup_parser</code></p>
<p>Signature: <code>(self) -&gt; Iterable[midgard.parsers._parser_chain.ParserDef]</code></p>
<p>Parsers defined for reading ANTEX file line by line.</p>
<p>First the ANTEX header information are read and afterwards the ANTEX corrections.</p>
<h1 id="midgardparsersrinex3_header">midgard.parsers.rinex3_header</h1>
<p>A parser for reading IVS source names translation table</p>
<h2 id="rinex3headermixin"><strong>Rinex3HeaderMixin</strong></h2>
<p>Full name: <code>midgard.parsers.rinex3_header.Rinex3HeaderMixin</code></p>
<p>Signature: <code>()</code></p>
<p>A mixin defining which headers are mandatory and optional in Rinex 3</p>
<h2 id="rinex3headerparser"><strong>Rinex3HeaderParser</strong></h2>
<p>Full name: <code>midgard.parsers.rinex3_header.Rinex3HeaderParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;, strict:bool=False) -&gt; None</code></p>
<p>A parser for reading just the Rinex3 header</p>
<p>The data in the rinex file will not be parsed.</p>
<h3 id="rinex3headerparsername-str">Rinex3HeaderParser.name (str)</h3>
<p><code>name = 'Rinex'</code></p>
<h3 id="rinex3headerparserread_epochs">Rinex3HeaderParser.<strong>read_epochs</strong>()</h3>
<p>Full name: <code>midgard.parsers.rinex3_header.read_epochs</code></p>
<p>Signature: <code>(self, fid) -&gt; None</code></p>
<p>Do not read data from Rinex file</p>
<p>Skip reading of data.</p>
<h1 id="midgardparsersrinex_obs">midgard.parsers.rinex_obs</h1>
<p>A parser for reading Rinex observation files</p>
<h2 id="rinexobsparser"><strong>RinexObsParser</strong></h2>
<p>Full name: <code>midgard.parsers.rinex_obs.RinexObsParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;, strict:bool=False) -&gt; None</code></p>
<p>A parser for reading Rinex observation files</p>
<p>Different versions of the Rinex format are implemented as subclasses</p>
<h3 id="rinexobsparsername-str">RinexObsParser.name (str)</h3>
<p><code>name = 'Rinex'</code></p>
<h3 id="rinexobsparserread_data">RinexObsParser.<strong>read_data</strong>()</h3>
<p>Full name: <code>midgard.parsers.rinex_obs.read_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Dispatch to correct subclass based on version in Rinex file</p>
<p>Need to make sure the dispatch only happens for RinexObsParsers, not for subclasses.</p>
<h1 id="midgardparsersvlbi_source_names">midgard.parsers.vlbi_source_names</h1>
<p>A parser for reading IVS source names translation table</p>
<h2 id="vlbisourcenamesparser"><strong>VlbiSourceNamesParser</strong></h2>
<p>Full name: <code>midgard.parsers.vlbi_source_names.VlbiSourceNamesParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;) -&gt; None</code></p>
<p>A parser for reading IVS source names translation table</p>
<p>See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file</p>
<h3 id="vlbisourcenamesparsersetup_parser">VlbiSourceNamesParser.<strong>setup_parser</strong>()</h3>
<p>Full name: <code>midgard.parsers.vlbi_source_names.setup_parser</code></p>
<p>Signature: <code>(self) -&gt; Dict[str, Any]</code></p>
<p>Set up information needed for the parser</p>
<p>This should return a dictionary with all parameters needed by np.genfromtxt to do the actual parsing.</p>
<p><strong>Returns:</strong></p>
<p>Parameters needed by np.genfromtxt to parse the input file.</p>
<h3 id="vlbisourcenamesparserstructure_data">VlbiSourceNamesParser.<strong>structure_data</strong>()</h3>
<p>Full name: <code>midgard.parsers.vlbi_source_names.structure_data</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Structure raw array data into the self.data dictionary</p>
<p>Using the IVS name as key.</p>
<h1 id="midgardparserswip_rinex2_obs">midgard.parsers.wip_rinex2_obs</h1>
<p>A parser for reading IVS source names translation table</p>
<h2 id="rinex2obsparser"><strong>Rinex2ObsParser</strong></h2>
<p>Full name: <code>midgard.parsers.wip_rinex2_obs.Rinex2ObsParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;, strict:bool=False) -&gt; None</code></p>
<p>A parser for reading IVS source names translation table</p>
<p>See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file</p>
<h3 id="rinex2obsparsername-str">Rinex2ObsParser.name (str)</h3>
<p><code>name = 'Rinex'</code></p>
<h1 id="midgardparserswip_rinex3_obs">midgard.parsers.wip_rinex3_obs</h1>
<p>A parser for reading IVS source names translation table</p>
<h2 id="rinex3obsparser"><strong>Rinex3ObsParser</strong></h2>
<p>Full name: <code>midgard.parsers.wip_rinex3_obs.Rinex3ObsParser</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], encoding:Union[str, NoneType]=None, logger:Union[Callable[[str], NoneType], NoneType]=&lt;built-in function print&gt;, strict:bool=False) -&gt; None</code></p>
<p>A parser for reading IVS source names translation table</p>
<p>See https://vlbi.gsfc.nasa.gov/output for an example of a IVS source name file</p>
<h3 id="rinex3obsparserepoch_fields-dict">Rinex3ObsParser.EPOCH_FIELDS (dict)</h3>
<p><code>EPOCH_FIELDS = {'identifier': (0, 1), 'year': (2, 6), 'month': (7, 9), 'day': (10, 12), 'hour': (13, 15), 'minute': (16, 18), 'second': (19, 21), 'frac_sec': (21, 29), 'epoch_flag': (30, 32), 'num_data_lines': (33, 35)}</code></p>
<h3 id="rinex3obsparseras_dataframe">Rinex3ObsParser.<strong>as_dataframe</strong>()</h3>
<p>Full name: <code>midgard.parsers.wip_rinex3_obs.as_dataframe</code></p>
<p>Signature: <code>(self, system:str, index:Union[str, List[str], NoneType]=None) -&gt; pandas.core.frame.DataFrame</code></p>
<p>Return the parsed data as a Pandas DataFrame</p>
<p>This is a basic implementation, assuming the <code>self.data</code>-dictionary has
a simple structure. More advanced parsers may need to reimplement this
method.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>index</code>:  Optional name of field to use as index. May also be a list of strings.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Pandas DataFrame with the parsed data.</p>
<h3 id="rinex3obsparsername-str">Rinex3ObsParser.name (str)</h3>
<p><code>name = 'Rinex'</code></p>
<h3 id="rinex3obsparserparse_data_lines">Rinex3ObsParser.<strong>parse_data_lines</strong>()</h3>
<p>Full name: <code>midgard.parsers.wip_rinex3_obs.parse_data_lines</code></p>
<p>Signature: <code>(self, lines, epoch_info) -&gt; Dict[str, Any]</code></p>
<p>Read one section of data lines</p>
<h3 id="rinex3obsparserparse_epoch_line">Rinex3ObsParser.<strong>parse_epoch_line</strong>()</h3>
<p>Full name: <code>midgard.parsers.wip_rinex3_obs.parse_epoch_line</code></p>
<p>Signature: <code>(self, line) -&gt; Dict[str, Any]</code></p>
<p>Read data from Rinex file</p>
<p>Add data to self.data</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
